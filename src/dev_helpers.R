owrite_tracker = function(){
    tracker_path = glue::glue('data/{n}/{d}/data_tracker.json',
        n=network, d=domain)
    jsonlite::write_json(held_data, tracker_path)
}

export_all_local_helpers <- function(outfile){

    #needs work (run body interactively and it'll work)

    require(tidyverse)
    require(glue)

    sw = suppressWarnings

    try(setwd('~/git/macrosheds/data_acquisition'), silent=TRUE) #mike
    try(setwd('~/desktop/macrosheds/data_acquisition'), silent=TRUE) #spencer

    network_domain = read_csv('data/general/site_data.csv') %>%
        filter(as.logical(in_workflow)) %>%
        select(network, domain) %>%
        distinct() %>%
        arrange(network, domain)

    get_all_local_helpers <- function(network=domain, domain){

        #source_decoratees reads in decorator functions (tinsel package).
        #because it can only read them into the current environment, all files
        #sourced by this function are exported locally, then exported globally

        location1 = glue('src/{n}/network_helpers.R', n=network)
        if(file.exists(location1)){
            sw(source(location1, local=TRUE))
            # sw(source_decoratees(location1))
        }

        location2 = glue('src/{n}/{d}/domain_helpers.R', n=network, d=domain)
        if(file.exists(location2)){
            sw(source(location2, local=TRUE))
            # sw(source_decoratees(location2))
        }

        location3 = glue('src/{n}/processing_kernels.R', n=network)
        if(file.exists(location3)){
            sw(source(location3, local=TRUE))
            # sw(source_decoratees(location3))
        }

        location4 = glue('src/{n}/{d}/processing_kernels.R', n=network, d=domain)
        if(file.exists(location4)){
            sw(source(location4, local=TRUE))
            # sw(source_decoratees(location4))
        }

        rm(location1, location2, location3, location4)

        export_to_global(from_env=environment(),
            exclude=c('network', 'domain', 'thisenv'))

        return()
    }

    export_to_global <- function(from_env, exclude=NULL){

        #exclude is a character vector of names not to export.
        #unmatched names will be ignored.

        #vars could also be passed individually and handled by ...
        # vars = list(...)
        # varnames = all.vars(match.call())

        varnames = ls(name=from_env)
        varnames = varnames[! varnames %in% exclude]
        vars = mget(varnames, envir=from_env)

        for(i in 1:length(varnames)){
            assign(varnames[i], vars[[i]], .GlobalEnv)
        }

        return()
    }

    for(dmnrow in 1:nrow(network_domain)){

        network = network_domain$network[dmnrow]
        domain = network_domain$domain[dmnrow]

        get_all_local_helpers(network=network, domain=domain)
    }

    rm(ms_pasta_domain_refmap, export_all_local_helpers, dmnrow,
        domain, network, export_to_global, get_all_local_helpers,
        outfile, sw, envir=.GlobalEnv)

    write.csv(data.frame(funcname=ls()), outfile)

    return()
}

export_all_global_helpers <- function(outfile){

    #needs work (run body interactively and it'll work)

    try(setwd('~/git/macrosheds/data_acquisition'), silent=TRUE) #mike
    try(setwd('~/desktop/macrosheds/data_acquisition'), silent=TRUE) #spencer

    source('src/function_aliases.R')

    thisenv = environment()
    aliases = ls(envir=thisenv)

    source('src/global_helpers.R')

    rm(email_err_msgs, err_cnt, unique_errors, unique_exceptions, flagmap,
        envir=.GlobalEnv)
    rm(list=aliases, envir=.GlobalEnv)

    write.csv(data.frame(funcname=ls()), outfile)

    return()
}

compare_interp_methods <- function(){
    m1 <- reconstitute_raster(precip_idw, dem_wbj)
    m2 <- reconstitute_raster(precip_from_elev, dem_wbj)
    m3 <- reconstitute_raster(precip_interp, dem_wbj)
    par(mfrow=c(2, 3))
    # plot(idw_mask2, main='interpolation')
    plot(m0, main='idw') #generated by interpolate, see test kernel
    plot(m1, main='id^2w')
    plot(1, 1, type='n', axes=FALSE, xlab='', ylab='')
    plot(dem_wbj, main='dem')
    plot(m2, main='elev only')
    plot(m3, main='idw^2 and elev')
}

invalidate_tracked_data <- function(network, domain, level){

    #level is one of 'munge' or 'derive'. that level will be reset
    #not currently set up to invalidate level='retrieve'

    tracker <- get_data_tracker(network = network,
                                domain = domain)

    invalidated <- recursive_tracker_update(l = tracker,
                                            elem_name = level,
                                            new_val = list(status = 'pending',
                                                           mtime = '1500-01-01'))

    return(invalidated)
}

assign_typical_test_variables <- function(){

    try(assign('tracker', held_data, envir = .GlobalEnv))
    try(assign('i', 1, envir = .GlobalEnv))
    try(assign('j', 1, envir = .GlobalEnv))
    try(assign('k', 1, envir = .GlobalEnv))
    try(assign('sets', new_sets, envir = .GlobalEnv))
    try(assign('s', sets[i, ], envir = .GlobalEnv))
    try(assign('set_details', s, envir = .GlobalEnv))

    return()
}

compare_efficiency <- function(f, g, stepstart=10, stepstop=1e5, outfile){

    #f and g are expressions to be compared. they must both contain a variable
    #   `s` that will take a value of `step` for each iteration.
    #stepstart and stepstop are powers of 10. step is a sequence from stepstart
    #   to stepstop, increasing by powers of 10.

    #ratio easier to grasp if you make f the slower function (then it can be read
    #   as "f is this much slower than g")

    if(stepstart >= stepstop){
        stop('stepstart must be less than stepstop')
    }

    if(length(stepstart) != 1 || length(stepstop) != 1){
        stop('both stepstart and stepstop must be integers')
    }

    if(log10(stepstart) %% 1 != 0 || log10(stepstop) %% 1 != 0){
        stop('both stepstart and stepstop must be powers of 10')
    }

    step = 10 ^ seq(log10(stepstart), log10(stepstop))

    ftimes = gtimes = ratios = rep(NA, length = length(step))
    cnt = 1
    for(s in step){

        tt = Sys.time()
        eval(f)
        tt1 = difftime(Sys.time(), tt, units = 'sec')

        tt = Sys.time()
        eval(g)
        tt2 = difftime(Sys.time(), tt, units = 'sec')

        ftimes[cnt] = as.numeric(tt1)
        gtimes[cnt] = as.numeric(tt2)
        ratios[cnt] = as.numeric(tt1)/as.numeric(tt2)

        cnt = cnt + 1

        # print(paste0('err is ',
        #              round(as.numeric(tt2)/as.numeric(tt1), 2),
        #              'X slower'))
    }

    logstep = log(step)
    plotseq = seq(logstep[1], logstep[length(logstep)], 0.1)
    if(! missing(outfile)){
        mainlab = str_match(outfile, '.*/(.+)?\\.png$')[, 2]
    } else {
        mainlab = ''
    }

    # mf = lm(ftimes ~ logstep + I(logstep^2))
    # mg = lm(log(gtimes) ~ logstep)
    # mr = lm(ratios ~ logstep + I(logstep^2))
    # # p = predict(m, data.frame(x=plotseq))
    # # lines(plotseq, p)

    if(! missing(outfile)){
        png(width=5, height=5, units='in', res=300, filename=outfile,
            type='cairo')
    }

    par(mar=c(4, 4, 3, 4), oma=c(0, 0, 0, 0))
    ylims = range(c(ftimes, gtimes), na.rm=TRUE)
    # ylims = range(c(fitted(mf), fitted(mg)), na.rm=TRUE)
    plot(logstep, ftimes, col='red', ylim=ylims, type='l',
    # plot(logstep, fitted(mf), col='red', ylim=ylims, type='l',
         xlab = 'length', ylab = 'sec', xaxt='n', main=mainlab)
    options(scipen=-1000)
    axis(1, at=logstep, labels=step, las=3)
    options(scipen=0)
    lines(logstep, gtimes, col='blue')
    # lines(logstep, fitted(mg), col='blue')
    par(new = TRUE)
    plot(logstep, ratios, col='gray', type='l', yaxt='n', xaxt='n', xlab='',
    # plot(logstep, fitted(mr), col='gray', type='l', yaxt='n', xaxt='n', xlab='',
         ylab='', lty=3)
    axis(4)
    mtext('f-g ratio', 4, line=2.5, col='gray40')

    legend('top', legend=c('f', 'g', 'f:g'), col=c('red', 'blue', 'gray'),
           lty=c(1, 1, 3), bty='n')

    if(! missing(outfile)){
        dev.off()
    }

    return()
}
